package com.ebay.epic.utils;

import com.ebay.epic.common.env.EnvironmentUtils;
import com.ebay.epic.common.state.StateBackendFactory;
import com.google.common.collect.Maps;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.apache.flink.api.java.utils.ParameterTool;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.configuration.TaskManagerOptions;
import org.apache.flink.streaming.api.CheckpointingMode;
import org.apache.flink.streaming.api.TimeCharacteristic;
import org.apache.flink.streaming.api.environment.CheckpointConfig;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;

import java.io.IOException;
import java.io.InputStream;
import java.util.*;


@Slf4j
public class FlinkEnvUtils {

    private static final Map<String, String> CONFIG = Maps.newHashMap();

    private static void load(String[] args) {
        ParameterTool parameterTool = ParameterTool.fromArgs(args);
        String profile = parameterTool.get(Property.PROFILE);
        if (StringUtils.isNotBlank(profile)) {
            CONFIG.put(Property.PROFILE, profile);
            EnvironmentUtils.activateProfile(profile);
        }
        EnvironmentUtils.fromProperties(parameterTool.getProperties());

        // load git.properties file if exists
        try (InputStream input = FlinkEnvUtils.class.getClassLoader()
                .getResourceAsStream("git.properties")) {
            Properties prop = new Properties();

            if (input == null) {
                log.info("Not found git.properties file");
                return;
            }

            //load git.properties and put props into CONFIG map
            prop.load(input);
            for (String key : prop.stringPropertyNames()) {
                CONFIG.put(key, prop.getProperty(key));
            }
        } catch (IOException e) {
            log.error("Error when loading git.properties file", e);
        }
    }

    public static StreamExecutionEnvironment prepare(String[] args) {
        load(args);
        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.getConfig().disableAutoGeneratedUIDs();
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        // checkpoint config
        // create a checkpoint every 5 minutes
        env.enableCheckpointing(getInteger(Property.CHECKPOINT_INTERVAL_MS));
        CheckpointConfig conf = env.getCheckpointConfig();
        conf.setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);
        conf.setMinPauseBetweenCheckpoints(getInteger(Property.CHECKPOINT_MIN_PAUSE_BETWEEN_MS));//2min
        conf.setCheckpointTimeout(getInteger(Property.CHECKPOINT_TIMEOUT_MS));//15min
        conf.setMaxConcurrentCheckpoints(getInteger(Property.CHECKPOINT_MAX_CONCURRENT));
        conf.setTolerableCheckpointFailureNumber(getInteger(Property.TOLERATE_FAILURE_CHECKPOINT_NUMBER));

        // state config
        env.setStateBackend(StateBackendFactory.getStateBackend(StateBackendFactory.ROCKSDB));

        return env;
    }

    public static StreamExecutionEnvironment prepare4Local(String[] args) {
        load(args);
        final int parallelism = 1;
        final Configuration configuration = new Configuration();
        configuration.setInteger(TaskManagerOptions.NUM_TASK_SLOTS, 8);
        final StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment(parallelism,configuration);
        env.getConfig().disableAutoGeneratedUIDs();
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

        // checkpoint config
        // create a checkpoint every 5 minutes
        env.enableCheckpointing(getInteger(Property.CHECKPOINT_INTERVAL_MS));
        CheckpointConfig conf = env.getCheckpointConfig();
        conf.setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);
        conf.setMinPauseBetweenCheckpoints(getInteger(Property.CHECKPOINT_MIN_PAUSE_BETWEEN_MS));//2min
        conf.setCheckpointTimeout(getInteger(Property.CHECKPOINT_TIMEOUT_MS));//15min
        conf.setMaxConcurrentCheckpoints(getInteger(Property.CHECKPOINT_MAX_CONCURRENT));
        conf.setTolerableCheckpointFailureNumber(getInteger(Property.TOLERATE_FAILURE_CHECKPOINT_NUMBER));

        // state config
        env.setStateBackend(StateBackendFactory.getStateBackend(StateBackendFactory.ROCKSDB));

        return env;
    }
    public static void execute(StreamExecutionEnvironment env, String jobName) throws Exception {
        ParameterTool parameterTool = ParameterTool.fromMap(CONFIG);
        // make parameters available in the web interface
        env.getConfig().setGlobalJobParameters(parameterTool);
        env.execute(jobName);
    }

    public static String getString(String key) {
        String value = EnvironmentUtils.get(key);
        CONFIG.put(key, value);
        return value;
    }

    public static String getStringOrDefault(String key, String defaultValue) {
        String value = EnvironmentUtils.getStringOrDefault(key, defaultValue);
        CONFIG.put(key, value);
        return value;
    }

    public static Integer getInteger(String key) {
        String value = EnvironmentUtils.get(key);
        CONFIG.put(key, value);
        return Integer.valueOf(value);
    }

    public static Integer getIntegerOrDefault(String key,Integer defaultKey) {
        Integer value = EnvironmentUtils.getIntegerOrDefault(key,defaultKey);
        CONFIG.put(key, String.valueOf(value));
        return value;
    }

    public static Long getLong(String key) {
        String value = EnvironmentUtils.get(key);
        CONFIG.put(key, value);
        return Long.valueOf(value);
    }

    public static Boolean getBoolean(String key) {
        String value = EnvironmentUtils.get(key);
        CONFIG.put(key, value);
        return Boolean.valueOf(value);
    }

    public static String getListString(String key) {
        List<String> list = EnvironmentUtils.getOrNull(key, List.class);
        if(list==null){
            return null;
        }else {
            String value = String.join(",", list);
            CONFIG.put(key, value);
            return value;
        }
    }

    public static Set<String> getSet(String key) {
        List<String> list = EnvironmentUtils.get(key, List.class);
        String value = String.join(",", list);
        CONFIG.put(key, value);
        return new HashSet<>(list);
    }

    public static List<String> getList(String key) {
        List<String> list = EnvironmentUtils.get(key, List.class);
        String value = String.join(",", list);
        CONFIG.put(key, value);
        return list;
    }

    public static String[] getStringArray(String key, String delimiter) {
        String value = EnvironmentUtils.get(key);
        CONFIG.put(key, value);
        return EnvironmentUtils.getStringArray(key, delimiter);
    }

    public static List<String> getStringList(String key, String delimiter) {
        String value = EnvironmentUtils.get(key);
        CONFIG.put(key, value);
        return EnvironmentUtils.getStringList(key, delimiter);
    }
    public static Float getFloat(String key) {
        String value = EnvironmentUtils.get(key);
        CONFIG.put(key, value);
        return Float.valueOf(value);
    }
}
